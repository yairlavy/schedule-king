import os
from pathlib import Path
import pytest
import time
from unittest.mock import patch
from src.api.schedule_api import ScheduleAPI

# Fixture to load the test file and create ScheduleAPI instance
@pytest.fixture
def schedule_api(tmp_path):
    # Get absolute paths for test files
    base_dir = os.path.dirname(__file__)
    input_file_path = os.path.join(base_dir, "test_files", "input_test_api.txt")
    output_file = tmp_path / "output.txt"
    
    # Create the ScheduleAPI instance
    api = ScheduleAPI(file_path=input_file_path, output_path=str(output_file))
    return api

#SCHEDULE_API_FUNC_001
def test_process_single_course(schedule_api):
    print("Running test_process_single_course with simulated input '00001'")
   
    with patch("builtins.input", return_value="00001"):
        output = schedule_api.process() 

    print(f"Output for test_process_single_course:\n{output}")
    
    assert output is not None
    assert "Calculus 1" in output

#SCHEDULE_API_FUNC_002
def test_process_multiple_courses(schedule_api):
    print("Running test_process_multiple_courses with simulated input '00001 83533'")
   
    with patch("builtins.input", return_value="00001 83533"):
        output = schedule_api.process() 
   
    print(f"Output for test_process_multiple_courses:\n{output}")
    
    assert output is not None
    assert "Calculus 1" in output
    assert "Software Project" in output

#SCHEDULE_API_FUNC_003
def test_output_file_contains_all_schedules(schedule_api):
    """
    Test that after processing, the output file contains all the generated schedules.
    """
    with patch("builtins.input", return_value="00001"):
        schedule_api.process()
   
    output_file = Path(schedule_api.file_handler.formatter.path)
    content = output_file.read_text(encoding="utf-8")
    print(f"File content for test_output_file_contains_all_schedules:\n{content}")
   
    # Check that the file content contains schedule separators and schedule labels.
    assert "Schedule 1:" in content
   
    # Check for at least one valid day label.
    assert any(day in content for day in ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"])

#SCHEDULE_API_VALID_001
def test_invalid_course_code(schedule_api, capsys):
    """
    Test behavior when an invalid course code is provided.
    First, an invalid code ("99999") is given, then a valid code ("00001") is provided.
    """
    with patch('builtins.input', side_effect=["99999", "00001"]):
        output = schedule_api.process()  # process() will prompt for input.
        print(f"Output for test_invalid_course_code:\n{output}")
        captured = capsys.readouterr()
   
        # Check that the error message was printed
        assert "Error: Invalid course codes:" in captured.out
   
        # After correction, the output should include Calculus 1.
        assert output is not None
        assert "Calculus 1" in output

#SCHEDULE_API_VALID_002
def test_exceed_course_limit(schedule_api, capsys):
    """
    Simulate too many course codes being entered, then retry with valid codes.
    The first input exceeds the limit of 7 courses, which return none.
    The second input is valid and should succeed.
    """
    # First input: 8 courses (invalid), triggers re-prompt
    # Second input: 3 courses (valid), should pass
    inputs = [
        "00001 83533 83112 10001 10002 10003 10004 10005",  # invalid: 8 courses
        "00001 83533 83112"  # valid: 3 courses
    ]
   
    with patch("builtins.input", side_effect=inputs):
        schedule_api.process()
        captured = capsys.readouterr()
   
        # Check that error message was printed
        assert "Error: Cannot select more than 7 courses." in captured.out
        assert "Selected Courses:" in captured.out
        assert "Calculus 1" in captured.out
        assert "Software Project" in captured.out
        assert "Calculus 1 (eng)" in captured.out

#SCHEDULE_API_VALID_003
def test_output_matches_expected(tmp_path):
    """
    Test if output file matches the expected output file.
    This test compares the actual output file generated by the API with a pre-defined expected output file.
    """
    # Get absolute paths for test files
    base_dir = os.path.dirname(__file__)
    input_file_path = os.path.join(base_dir, "test_files", "test_short_schedule_intput.txt")
    expected_output = os.path.join(base_dir, "test_files", "expected_test_short_schedule_intput.txt")
    actual_output = tmp_path / "actual_output.txt"

    # Create the ScheduleAPI instance
    schedule_api = ScheduleAPI(file_path=input_file_path, output_path=actual_output)

    # Patch input to simulate user entering course codes
    with patch("builtins.input", return_value="83533 83255"):
        schedule_api.process()
    
    # Read the content of both files
    with open(actual_output, "r", encoding="utf-8") as actual_file:
        actual_content = actual_file.read()
    with open(expected_output, "r", encoding="utf-8") as expected_file:
        expected_content = expected_file.read()
    
    # Compare actual output file to expected file
    assert actual_content == expected_content

    # now test if it does not match when we change the input
    # Patch input to simulate user entering different course codes
    with patch("builtins.input", return_value="83533"):
        schedule_api.process()
    
    # Read the content of both files again
    with open(actual_output, "r", encoding="utf-8") as actual_file:
        actual_content = actual_file.read()
    
    # Compare actual output file to expected file
    assert actual_content != expected_content

#SCHEDULE_API_PERF_001
def test_7course_performance(tmp_path):
    """
    This test simulates the input of 7 valid course codes and measures the time taken to process them.
    """
    
    # Get absolute paths for test files
    base_dir = os.path.dirname(__file__)
    input_file_path = os.path.join(base_dir, "test_files", "7courses.txt")
    output_file = tmp_path / "output_7course.txt"
    
    schedule_api = ScheduleAPI(file_path=input_file_path, output_path=str(output_file))
    
    input = "10101 10102 10103 10104 10105 10106 10107"
    
    start_time = time.perf_counter()
    with patch("builtins.input", return_value=input):
        schedule_api.process()
    end_time = time.perf_counter()
    
    total_time = end_time - start_time
    print(f"Processing time for 7 courses: {total_time:.2f} seconds")
    assert total_time <= 10, f"Processing took too long: {total_time:.2f} seconds"